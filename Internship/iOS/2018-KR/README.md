# Overview
Задача -- конвертировать числа в порядковые числительные.
Решение -- Converter.

# Version 2.0
Реструктуризация. Классы Matcher и Numerals убраны. Убрана поддержка короткой-длинной шкалы. Сокращено количество форматтеров. Удалено создание словарей с помощью plist файлов.
Основной причиной удаления, была медленная работа класса по сравнению с NSNumberFormatter. Сейчас класс конвертирует число (в режиме количественных числительных) примерно также, как NSNumberFormatter.

Внешне ничего не изменилось. По прежнему основной класс Convertor, который по умолчанию (создание через alloc-init) поддерживает три языка. Поддержка определенного языка реализуется через создание наследника NumberFormatter, переопределения методов и заполнения полей данных. 

## Converter
### public properties
* **localeID** -- строка идентефикатор локали. Геттер возвращает информацию о текущей установленной локали. Сеттер переключает Converter на определенный словарь (если подходящий есть, если нет -- локаль остается прежней). Может быть nil (после удаления последнего словаря).
* **ordinal** -- переключатель режима порядковые/количественные (ordinal/cardinal). Проперти просто подключает/отключает одно из правил NumberFormatter.
* **availableLocaleID** -- возвращает массив доступных локалей. Динамическое проперти, только для чтения.

### private properties
* **formatters** -- массив текущих доступных Formatter'ов.
* **localeFormatter** -- Formatter соответствующий текущей `localeID`.

### public API
* **- init** -- создает Converter с тремя встроенными Formatter (en, de, ua). По умолчанию `ordinal` = YES, `localeID` = en.
* **- initWithFormatter:** -- создает Converter с единственным переданным Formatter'ом.
* **- addFormatter:** -- добавляет Formatter. Если это единственный форматтер, то он становится `currentFormatter`.
* **- removeFormatterWithLocale:** -- удаляет Formatter по его `localeID`. Если подходящей локали нет, ничего не происходит. Если есть подходящий и он `currentFormatter`, то он удаляется, а `currentFormatter`'ом становится первый из доступных `formatters`. Если есть подходящий и он последний, `localeID` сбрасывается в nil, Converter не работоспособен.

* **- stringFromNumber:** -- основной метод для конвертации числа в строку. Выполняет предварительную проверку на max-min допустимые значения и вызывает приватный метод `- convertNumber`.
* **- stringFromNumber: withLocale:** -- быстрый метод для конвертации числа с переключением локали в одну строку. Отключен пока.

### private API
* **- convertNumber:** -- делит число на "тройки", группы из трех цифр и отправляет их парсеру `threeDigitParser`, в ответ получает строки, которые собирает в массив. По окончании анализа вызывает `ordinalFormatter`(если `ordinal` = YES) и `finishingFormatter`.
* **- threeDiginParser:** -- последовательно вызывает методы Formatter для сотен, десятков и единиц. 
* **- isCorrectLocaleID:** -- сравнивает приходящий localeID с массивом доступных локалей.

## NumeralsFormatter
### public properties
* **localeID** -- к какому языку относится текущий экземпляр Formatter. Только для чтения.
* **cardinalUnits**, 
* **cardinalTens**,
* **cardinalHundreds**,
* **cardinalLarge** -- массивы для локализации единиц, десятков, сотен, тысяч, миллионов и т.д.
* **exceptions** -- в основном слова будут образовываться по правилам, но есть и исключения. Этот словарь словарей именно для хранения таких исключений. 

### private properties
* в NumeralsFormatter их нет. В неследниках необходимо добавить в расширении класса readwrite `localeID`, для установки значения по умолчанию в инитах.

### public API
* **- unitsFormatter: multiplier:**,
* **- tensFormatter: multiplier:**,
* **- hundredsFormatter: multiplier:**,
* **- largeFormatter: multiplier:** -- переводят единицы, десятки, сотни и тысячи в слова. Обычно просто подбор из массива слов. Для чисел больше 10 нужно реализовать "арифметику индекса", иногда заменить слова на исключения.
* **- ordinalFormatter: withParts:** -- заменяет количественные числительные на порядковые. Замена либо через добавления окончаний, либо подбор из словаря `exceptions`.
* **-finishingFormatter: withParts:** -- соединяет весь полученный набор слов в единую строку. Обычно здесь же формируется ноль. 

### private API
* в NumeralsFormatter дополнительных значимых методов нет. В наследниках в приватные методы выносятся вспомогательные действия.

# Example	 
Сингл вью iOS приложение, переводит введенное число в числительное. Ввод как ручной, так и генерация случайного числа. Случайное число ограниченно миллионом, ручной ввод -- не ограничен.

# Как подключить новый язык
1. Создать новый класс наследник **NumeralsFormatter**. В классе переопределить методы обрабатывающие отдельные цифры, а также создать новый инициализирующий метод, в котором задать значения внутренним словарям.
2. Создать конвертер с помощью `initWithFormatter:` или добавить к уже существующему `addFormatter:`.
5. Пользоваться.





# Version 1.0
Как таковой конвертер состоит из четырех классов: Converter, Matcher, Formatter, Numerals.
Converter

#### Converter
Предоставляет "единое окно" для пользователя, через его интерфейс можно запросить конвертацию, переключить локализацию, добавить словарь и т.п.
Также класс отвечает за предварительную подготовку полученного числа, дробит его на единицы, десятки, сотни и передает Matcher'у

#### Matcher  
Хранит набор Formatter'ов и управляет этим набором.
Анализирует полученные части числа и подбирает соответствующий метод Formatter.

#### Formatter
Правила формирования слов.
Именно форматтер делает из числа слово.  
Использует локализованные словари для единиц, десятков и т.п. Использует набор методов реализующих грамматику конкретного языка. Балланс использования словарей и правил выдерживает сам программист. 
Например, EnglishFormatter по максимуму использует правила, а DeutschFormatter - словари.
NumeralFormatter это базовый класс, многие методы интерфейса не имеют реализации. Необходимо создать новый класс, наследник от NumeralFormatter, и уже там реализовать грамматику конкретного языка.

#### Numerals
Локализованные словари. Структура обязательно содержит словари: cardinal, ordinal, cardinalLargeShort, cardinalLargeLong, ordinalLargeShort, ordinalLargeLong, exceptions. Хотя наличие самих словарей обязательно, они не обязательно должны быть заполненны. Например, английский ordinal пустой, число формируют по правилам и исключениям. 
Тысяча -- 1000 -- может быть или в обычном словаре или в Large, зависит от правил языка.
В украинском, числительные заканчивающиеся на тысячный, миллионный и т.д., пишутся слитно -- выгодно держать тысячу в Large.
В немецком, числительные Million, Milliard и.т.д пишутся с большой, а tausend -- нет, храним в обычных числа.
 
# Example	 
Сингл вью iOS приложение, переводит введенное число в числительное. Ввод как ручной, так и генерация случайного числа. Случайное число ограниченно миллионом, ручной ввод -- не ограничен.

# Как подключить новый язык
1. Создать новый словарь **Numerals**. Это можно сделать двумя способами, либо написать расширение класса с ручной установкой словарей и методом класса для инициализации (см. Numerals+English) . Либо создать plist (см. Supporting Files/uk.plist), прописать локализацию в нем, и создать экземпляр **Numerals** с помощью `initWithFile:`.
2. Создать новый класс, наследник **NumeralFormatters**, переопределить форматтеры. При создании подключить словарь с помощью `initWithNumbers:` или взять словарь прямо из plist `initWithFile:`.
3. Создать конвертер с помощью `initWithFormatter:` или добавить к уже существующему `addFormatter:`.
4. Пользоваться (см `testInitWithFormatter`).



